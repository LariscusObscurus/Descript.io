namespace Descriptio.Parser

open System
open System.Runtime.CompilerServices
open System.Text
open Descriptio.Parser.Core

module public MarkdownLexer =

    /// <summary>
    /// Represents the state of the lexer.
    /// </summary>
    type public State =
    | NewLine
    | TextLine
    | InlineCodeState
    | InlineCodeLiteralState
    | TitleLevelState
    | TitleState
    | TitleClosingState
    | ImageAltState
    | HyperlinkTextState
    | LinkState
    | LinkTitleState
    | EnumerationState
    | UnorderedEnumerationState
    | CodeBlockState
    | BlockquoteState

    /// <summary>
    /// Represents the stack symbols of the lexer.
    /// </summary>
    type public StackSymbols =
    | Z0
    | TextStack of char list
    | EmphasisStack of char
    | StrongStack of char
    | InlineCodeStack of State
    | ImageStack of State
    | HyperlinkStack of State
    | CodeBlockLanguageStack of string
    | CodeBlockContentStack of string
    | BlockquoteStack of State

    /// <summary>
    /// Represents the tokens generated by the lexing process.
    /// </summary>
    type public Token =
    | NewLineToken
    | EmphasisStartToken
    | EmphasisEndToken
    | StrongStartToken
    | StrongEndToken
    | InlineCodeStartToken
    | InlineCodeEndToken
    | TitleLevelToken
    | TitleToken of string
    | TitleClosingToken
    | TextToken of string
    | ImageAltStartToken
    | ImageAltEndToken
    | LinkTextStartToken
    | LinkTextEndToken
    | LinkStartToken
    | LinkEndToken
    | EnumerationToken of indent: int * number: int
    | UnorderedEnumerationToken of indent : int * char
    | CodeBlockStartToken
    | CodeBlockEndToken
    | CodeBlockLanguageToken of string
    | BlockquoteToken

    [<Extension>]
    type public CharListExtensions =
        [<Extension>]
        static member inline BuildString(self: char list) = (self |> List.fold (fun (sb : StringBuilder) -> sb.Append) (StringBuilder())).ToString()

    type public Rule = (char list * State * StackSymbols list * Token list) -> (char list * State * StackSymbols list * Token list) option

    let inline (++) list tail = list@[tail]
    let inline (!=) a b = a = b |> not

    let CharSeqUntil delimiters =
        let rec charSeq delimiters currentSeq input =
            match (input, currentSeq) with
            | ([], []) -> None
            | (c::_, []) when delimiters |> List.contains c -> None
            | (c::_, _) when delimiters |> List.contains c -> Some(currentSeq, input)
            | ([], _) -> Some(currentSeq, [])
            | (c::t, _) -> charSeq delimiters (currentSeq++c) t
        
        charSeq delimiters [] 

    let (|ImgLinkTitle|_|) = CharSeqUntil ['"']
    let (|LinkHrefChars|_|) = CharSeqUntil [' '; ')']
    let (|ImgOrLinkStack|_|) stack = match stack with ImageStack(st)::t | HyperlinkStack(st)::t -> Some(st, t) | _ -> None

    
    let (|StrongSupportedStack|_|) stack =
        match stack with
        | Z0::st | TextStack(_)::st | EmphasisStack(_)::st -> Some(st)
        | _ -> None

    let (|IsUnorderedEnumerationToken|_|) input =
        match input with
        | '*'::t -> Some('*', t)
        | '+'::t -> Some('+', t)
        | '-'::t -> Some('-', t)
        | _ -> None
    
    let (|EnumIndent|_|) =
        let rec enumIndent level input =
            match input with
            | '\t'::t
            | ' '::' '::' '::' '::t -> enumIndent (level+1) t
            | _ -> Some(level, input)
        
        enumIndent 0

    let (|LineBreak|_|) input =
        match input with
        | '\r'::'\n'::t
        | '\r'::t
        | '\n'::t -> Some t
        | _ -> None

    let (|Escaped|_|) input = match input with '\\'::c::t -> Some(c, t) | _ -> None

    let (|CollapsedWhitespaces|_|) =
        let rec collapseWhitespace hasWhitespace input =
            match input with
            | ' '::t -> collapseWhitespace true t
            | _ when hasWhitespace -> Some(input)
            | _ -> None
        
        collapseWhitespace false

    let (|InlineSupportedState|_|) state =
        match state with
        | NewLine -> Some TextLine
        | TextLine
        | EnumerationState
        | UnorderedEnumerationState
        | BlockquoteState -> Some state
        | _ -> None

    let (|BlockquoteSupportedState|_|) state =
        match state with
        | NewLine
        | BlockquoteState -> Some state
        | _ -> None

    let (|InlineState|_|) state =
        match state with
        | TextLine
        | EnumerationState
        | BlockquoteState
        | UnorderedEnumerationState -> Some state
        | _ -> None

    let (|TitleSupportedState|_|) state =
        match state with
        | NewLine
        | BlockquoteState -> Some state
        | _ -> None

    let (|IntNumber|_|) input =
        let rec GetIntNumber (input : char list) (digits : string) =
            match (input, digits) with
            | ([], "") -> None
            | ([], _) -> Some(digits |> Int32.Parse, [])
            | (delimiter::_, "") when delimiter |> Char.IsDigit |> not -> None
            | (delimiter::_, _) when delimiter |> Char.IsDigit |> not -> Some(digits |> Int32.Parse, input)
            | (digit::t, _) -> GetIntNumber t (digits + digit.ToString())
        
        GetIntNumber input ""

    let BlockquoteRules : Rule list = [
        fun (input, state, stack, output) ->
            match (input, state, stack) with
            | ('>'::CollapsedWhitespaces(t), BlockquoteSupportedState(s), [Z0]) -> Some(t, BlockquoteState, BlockquoteStack(s)::stack, output++BlockquoteToken)
            | (LineBreak(CollapsedWhitespaces(c::CollapsedWhitespaces(t))), BlockquoteState, BlockquoteStack(_)::_) when c = '>' |> not -> Some(c::t, BlockquoteState, stack, output)
            | (LineBreak(LineBreak(t)), BlockquoteState, BlockquoteStack(_)::st)
            | (LineBreak(CollapsedWhitespaces(LineBreak(t))), BlockquoteState, BlockquoteStack(_)::st) -> Some(t, NewLine, st, output++NewLineToken)
            | (LineBreak(LineBreak(t)), BlockquoteState, TextStack(txt)::BlockquoteStack(_)::st)
            | (LineBreak(CollapsedWhitespaces(LineBreak(t))), BlockquoteState, TextStack(txt)::BlockquoteStack(_)::st) -> Some(t, NewLine, st, output@[TextToken(txt.BuildString());NewLineToken])
            | (LineBreak(t), BlockquoteState, BlockquoteStack(s)::st) -> Some(t, s, st, output)
            | ([], BlockquoteState, [BlockquoteStack(_); Z0]) -> Some([], NewLine, [Z0], output)
            | ([], BlockquoteState, BlockquoteStack(_)::t) -> Some([], BlockquoteState, t, output)
            | _ -> None
        ]

    let CodeBlockRules(input, state, stack, output) =
        match (input, state, stack) with
        | ('`'::'`'::'`'::LineBreak(t), NewLine, [Z0]) -> Some(t, CodeBlockState, stack, output++CodeBlockStartToken)
        | ('`'::'`'::'`'::t, NewLine, [Z0]) -> Some(t, CodeBlockState, CodeBlockLanguageStack("")::stack, output++CodeBlockStartToken)
        | (LineBreak('`'::'`'::'`'::LineBreak(t)), CodeBlockState, [CodeBlockContentStack(cnt); Z0]) -> Some(t, NewLine, [Z0], output@[TextToken(cnt); CodeBlockEndToken])
        | (LineBreak('`'::'`'::'`'::[]), CodeBlockState, [CodeBlockContentStack(cnt); Z0]) -> Some([], NewLine, [Z0], output@[TextToken(cnt); CodeBlockEndToken])
        | (c::t, CodeBlockState, [CodeBlockContentStack(cnt); Z0]) -> Some(t, CodeBlockState, [CodeBlockContentStack(cnt + c.ToString()); Z0], output)
        | (c::t, CodeBlockState, [Z0]) -> Some(t, CodeBlockState, CodeBlockContentStack(c.ToString())::stack, output)
        | (c::LineBreak(t), CodeBlockState, CodeBlockLanguageStack(lang)::s) -> Some(t, CodeBlockState, s, output++CodeBlockLanguageToken(String.Concat(lang, c.ToString())))
        | (c::t, CodeBlockState, CodeBlockLanguageStack(lang)::s) -> Some(t, CodeBlockState, CodeBlockLanguageStack(String.Concat(lang, c.ToString()))::s, output)
        | _ -> None

    let titleRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | ('#'::CollapsedWhitespaces(t), TitleSupportedState _, _) -> Some(t, TitleState, stack, output++TitleLevelToken)
                | ('#'::CollapsedWhitespaces(t), TitleLevelState, _) -> Some(t, TitleState, stack, output++TitleLevelToken)
                | (LineBreak('#'::t), TextLine, _)
                | ('#'::t, TitleSupportedState _, _)
                | ('#'::t, TitleLevelState, _) -> Some(t, TitleLevelState, stack, output++TitleLevelToken)
                | _ -> None;
                
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (CollapsedWhitespaces('#'::t), TitleState, TextStack(txt)::s)
                | ('#'::t, TitleState, TextStack(txt)::s) -> Some(t, TitleClosingState, s, output@[TitleToken(txt.BuildString());TitleClosingToken])
                | ('#'::t, TitleClosingState, _) -> Some(t, TitleClosingState, stack, output++TitleClosingToken)
                | _ -> None;

            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (LineBreak(t), TitleState, TextStack(txt)::BlockquoteStack(s)::st) -> Some(t, s, st, output@[TitleToken(txt.BuildString())])
                | (LineBreak(t), TitleState, TextStack(txt)::s) -> Some(t, NewLine, s, output@[TitleToken(txt.BuildString());NewLineToken])
                | (LineBreak(t), TitleClosingState, BlockquoteStack(s)::st) -> Some(t, s, st, output)
                | (LineBreak(t), TitleClosingState, _) -> Some(t, NewLine, stack, output++NewLineToken)
                | ([], TitleState, TextStack(txt)::s) -> Some([], NewLine, s, output++TitleToken(txt.BuildString()))
                | ([], TitleClosingState, _) -> Some([], NewLine, stack, output)
                | _ -> None;
                
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (c::t, TitleState, TextStack(txt)::s) -> Some(t, TitleState, TextStack(txt++c)::s, output)
                | (c::t, TitleState, _) -> Some(t, TitleState, TextStack([c])::stack, output)
                | _ -> None;
        ]

    let unorderedEnumerationRules(input, state, stack, output) =
        match (input, state, stack) with
        | (EnumIndent(indent, IsUnorderedEnumerationToken(chr, CollapsedWhitespaces(t))), NewLine, [Z0])
            -> Some(t, UnorderedEnumerationState, stack, output++UnorderedEnumerationToken(indent, chr))

        | (LineBreak(EnumIndent(indent, IsUnorderedEnumerationToken(chr, CollapsedWhitespaces(t)))), UnorderedEnumerationState, [Z0])
            -> Some(t, UnorderedEnumerationState, stack, output++UnorderedEnumerationToken(indent, chr))

        | (LineBreak(EnumIndent(indent, IsUnorderedEnumerationToken(chr, CollapsedWhitespaces(t)))), UnorderedEnumerationState, [TextStack(txt);Z0])
            -> Some(t, UnorderedEnumerationState, [Z0], output@[TextToken(txt.BuildString());UnorderedEnumerationToken(indent, chr)])

        | (LineBreak(LineBreak(t)), UnorderedEnumerationState, [TextStack(txt);Z0])
            -> Some(t, NewLine, [Z0], output@[TextToken(txt.BuildString()); NewLineToken])

        | (LineBreak(LineBreak(t)), UnorderedEnumerationState, [Z0])
            -> Some(t, NewLine, stack, output++NewLineToken)

        | _ -> None;
    
    let enumerationRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (EnumIndent(indent, IntNumber(number, '.'::CollapsedWhitespaces(t))), NewLine, [Z0])
                    -> Some(t, EnumerationState, stack, output++EnumerationToken(indent, number))

                | (LineBreak(EnumIndent(indent, IntNumber(number, '.'::CollapsedWhitespaces(t)))), EnumerationState, [Z0])
                    -> Some(t, EnumerationState, stack, output++EnumerationToken(indent, number))

                | (LineBreak(EnumIndent(indent, IntNumber(number, '.'::CollapsedWhitespaces(t)))), EnumerationState, [TextStack(txt);Z0])
                    -> Some(t, EnumerationState, [Z0], output@[TextToken(txt.BuildString());EnumerationToken(indent, number)])

                | (LineBreak(LineBreak(t)), EnumerationState, [TextStack(txt);Z0])
                    -> Some(t, NewLine, [Z0], output@[TextToken(txt.BuildString()); NewLineToken])

                | (LineBreak(LineBreak(t)), EnumerationState, [Z0])
                    -> Some(t, NewLine, stack, output++NewLineToken)
                | _ -> None;
        ]

    let blockRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (LineBreak(LineBreak t), TextLine, TextStack(txt)::st) -> Some(t, NewLine, st, output@[TextToken(txt.BuildString()); NewLineToken])
                | (LineBreak(LineBreak t), NewLine, [Z0]) -> Some(t, NewLine, stack, output++NewLineToken)
                | _ -> None;
        ]

    let imageHyperlinkRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | ('!'::'['::t, InlineSupportedState s, TextStack(txt)::st) -> Some(t, ImageAltState, ImageStack(s)::st, output@[TextToken(txt.BuildString());ImageAltStartToken])
                | ('!'::'['::t, InlineSupportedState s, _) -> Some(t, ImageAltState, ImageStack(s)::stack, output++ImageAltStartToken)

                | ('['::t, InlineSupportedState s, TextStack(txt)::st) -> Some(t, HyperlinkTextState, HyperlinkStack(s)::st, output@[TextToken(txt.BuildString());LinkTextStartToken])
                | ('['::t, InlineSupportedState s, _) -> Some(t, HyperlinkTextState, HyperlinkStack(s)::stack, output++LinkTextStartToken)

                | (']'::'('::t, ImageAltState, TextStack(txt)::s) -> Some(t, LinkState, s, output++TextToken(txt.BuildString())++ImageAltEndToken++LinkStartToken)
                | (']'::'('::t, HyperlinkTextState, TextStack(txt)::s) -> Some(t, LinkState, s, output++TextToken(txt.BuildString())++LinkTextEndToken++LinkStartToken)

                | (c::t, ImageAltState, TextStack(txt)::ImageStack(st)::s) -> Some(t, state, TextStack(txt++c)::ImageStack(st)::s, output)
                | (c::t, HyperlinkTextState, TextStack(txt)::HyperlinkStack(st)::s) -> Some(t, state, TextStack(txt++c)::HyperlinkStack(st)::s, output)
                | (c::t, ImageAltState, ImageStack(_)::_)
                | (c::t, HyperlinkTextState, HyperlinkStack(_)::_) -> Some(t, state, TextStack([c])::stack, output)
 
                | ('"'::')'::t, LinkTitleState, TextStack(txt)::ImageStack(oldState)::st)
                | (')'::t, LinkState, TextStack(txt)::ImageStack(oldState)::st)
                | ('"'::')'::t, LinkTitleState, TextStack(txt)::HyperlinkStack(oldState)::st)
                | (')'::t, LinkState, TextStack(txt)::HyperlinkStack(oldState)::st) -> Some(t, oldState, st, output++TextToken(txt.BuildString())++LinkEndToken)

                | (LinkHrefChars(txt, t), LinkState, ImgOrLinkStack(_)) -> Some(t, state, TextStack(txt)::stack, output)
                | (ImgLinkTitle(txt, t), LinkTitleState, ImgOrLinkStack(_)) -> Some(t, state, TextStack(txt)::stack, output)
                | (' '::'"'::t, LinkState, TextStack(txt)::s) -> Some(t, LinkTitleState, s, output++TextToken(txt.BuildString()))

                | _ -> None;
        ]

    let inlineCodeRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | ('`'::'`'::t, InlineCodeLiteralState, TextStack(txt)::InlineCodeStack(st)::s) -> Some(t, st, s, output++TextToken(txt.BuildString())++InlineCodeEndToken)
                | ('`'::'`'::t, InlineSupportedState st, TextStack(txt)::s) -> Some(t, InlineCodeLiteralState, InlineCodeStack(st)::s, output++TextToken(txt.BuildString())++InlineCodeStartToken)
                | ('`'::'`'::t, InlineSupportedState st, _) -> Some(t, InlineCodeLiteralState, InlineCodeStack(st)::stack, output++InlineCodeStartToken)
                | (LineBreak(t), InlineCodeLiteralState, TextStack(txt)::s) -> Some(t, InlineCodeLiteralState, TextStack(txt++' ')::s, output)
                | (LineBreak(t), InlineCodeState, TextStack(txt)::s) -> Some(t, InlineCodeState, TextStack(txt++' ')::s, output)

                | (c::t, InlineCodeLiteralState, TextStack(txt)::s) -> Some(t, InlineCodeLiteralState, TextStack(txt++c)::s, output)
                | (c::t, InlineCodeLiteralState, InlineCodeStack(_)::_) -> Some(t, InlineCodeLiteralState, TextStack([c])::stack, output)
                | ('`'::t, InlineCodeState, TextStack(txt)::InlineCodeStack(st)::s) -> Some(t, st, s, output++TextToken(txt.BuildString())++InlineCodeEndToken)
                | ('`'::t, InlineSupportedState st, TextStack(txt)::s) -> Some(t, InlineCodeState, InlineCodeStack(st)::s, output++TextToken(txt.BuildString())++InlineCodeStartToken)
                | ('`'::t, InlineSupportedState st, _) -> Some(t, InlineCodeState, InlineCodeStack(st)::stack, output++InlineCodeStartToken)
                | (LineBreak(t), InlineCodeState, TextStack(txt)::s) -> Some(t, state, TextStack(txt++' ')::s, output)
                | (c::t, InlineCodeState, TextStack(txt)::s) -> Some(t, state, TextStack(txt++c)::s, output)
                | (c::t, InlineCodeState, InlineCodeStack(_)::_) -> Some(t, state, TextStack([c])::stack, output)
                | _ -> None;
        ]

    let strongRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (Escaped('_', _), InlineSupportedState _, TextStack(_)::_)
                | (Escaped('*', _), InlineSupportedState _, TextStack(_)::_)
                | ('*'::' '::_, InlineSupportedState _, TextStack(_)::_)
                | ('_'::' '::_, InlineSupportedState _, TextStack(_)::_)
                | (' '::'*'::_, InlineSupportedState _, TextStack(_)::_) 
                | (' '::'_'::_, InlineSupportedState _, TextStack(_)::_) -> None
                | ('*'::'*'::t, InlineSupportedState st, TextStack(txt)::StrongStack('*')::s) -> Some(t, st, s, output++TextToken(txt.BuildString())++StrongEndToken)
                | ('*'::'*'::t, InlineSupportedState st, TextStack(txt)::s) -> Some(t, st, StrongStack('*')::s, output++TextToken(txt.BuildString())++StrongStartToken)
                | ('*'::'*'::t, InlineSupportedState st, _) -> Some(t, st, StrongStack('*')::stack, output++StrongStartToken)
                | ('_'::'_'::t, InlineSupportedState st, TextStack(txt)::StrongStack('_')::s) -> Some(t, st, s, output++TextToken(txt.BuildString())++StrongEndToken)
                | ('_'::'_'::t, InlineSupportedState st, TextStack(txt)::s) -> Some(t, st, StrongStack('_')::s, output++TextToken(txt.BuildString())++StrongStartToken)
                | ('_'::'_'::t, InlineSupportedState st, _) -> Some(t, st, StrongStack('_')::stack, output++StrongStartToken)
                | (LineBreak(t), InlineSupportedState st, TextStack(txt)::StrongStack(_)::_) -> Some(t, st, TextStack(txt++' ')::stack.Tail, output)
                | (c::t, InlineSupportedState st, TextStack(txt)::StrongStack(_)::_) -> Some(t, st, TextStack(txt++c)::stack.Tail, output)
                | (c::t, InlineSupportedState st, StrongStack(_)::_) -> Some(t, st, TextStack([c])::stack, output)
                | _ -> None;
        ]

    let emphasisRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | ('*'::t, InlineSupportedState st, TextStack(txt)::EmphasisStack('*')::s) -> Some(t, st, s, output++TextToken(txt.BuildString())++EmphasisEndToken)
                | ('*'::t, InlineSupportedState st, TextStack(txt)::s) -> Some(t, st, EmphasisStack('*')::s, output++TextToken(txt.BuildString())++EmphasisStartToken)
                | ('*'::t, InlineSupportedState st, _) -> Some(t, st, EmphasisStack('*')::stack, output++EmphasisStartToken)
                | ('_'::t, InlineSupportedState st, TextStack(txt)::EmphasisStack('_')::s) -> Some(t, st, s, output++TextToken(txt.BuildString())++EmphasisEndToken)
                | ('_'::t, InlineSupportedState st, TextStack(txt)::s) -> Some(t, st, EmphasisStack('_')::s, output++TextToken(txt.BuildString())++EmphasisStartToken)
                | ('_'::t, InlineSupportedState st, _) -> Some(t, st, EmphasisStack('_')::stack, output++EmphasisStartToken)
                | (LineBreak(t), InlineSupportedState st, TextStack(txt)::EmphasisStack(_)::_) -> Some(t, st, TextStack(txt++' ')::stack.Tail, output)
                | (c::t, InlineSupportedState st, TextStack(txt)::EmphasisStack(_)::_) -> Some(t, st, TextStack(txt++c)::stack.Tail, output)
                | (c::t, InlineSupportedState st, EmphasisStack(_)::_) -> Some(t, st, TextStack([c])::stack, output)
                | _ -> None;
        ]
    
    let textLineRules : Rule list = [
            fun (input, state, stack, output) ->
                match (input, state, stack) with
                | (CollapsedWhitespaces(t), NewLine, [Z0]) -> Some(t, state, [Z0], output)

                | (CollapsedWhitespaces(LineBreak(t)), InlineState s, TextStack(txt)::st)
                | (CollapsedWhitespaces(t), InlineState s, TextStack(txt)::st) -> Some(t, s, TextStack(txt++' ')::st, output)

                | (LineBreak(CollapsedWhitespaces(t)), TextLine, TextStack(txt)::st)
                | (LineBreak(t), TextLine, TextStack(txt)::st) -> Some(t, TextLine, TextStack(txt++' ')::st, output)
                | (c::t, NewLine, _) -> Some(t, TextLine, TextStack([c])::stack, output)
                | (c::t, InlineSupportedState s, TextStack(txt)::st) -> Some(t, s, TextStack(txt++c)::st, output)
                | (c::t, InlineSupportedState s, _) -> Some(t, s, TextStack([c])::stack, output)
                | ([], InlineSupportedState s, TextStack(txt)::st) -> Some([], s, st, output++TextToken(txt.BuildString()))
                | _ -> None;
        ]

    let rules : Rule list =
        textLineRules
        |> List.append emphasisRules
        |> List.append strongRules
        |> List.append inlineCodeRules
        |> List.append imageHyperlinkRules
        |> List.append blockRules
        |> List.append (enumerationRules++unorderedEnumerationRules)
        |> List.append (titleRules++CodeBlockRules)
        |> List.append BlockquoteRules

    type public TextLexer() =
        let rec lexer (inp, state, stack, output) =
            rules
            |> Seq.map (fun r -> r(inp, state, stack, output))
            |> Seq.filter Option.isSome
            |> Seq.map (fun r -> match r.Value with
                                  | ([], _, [Z0], _) -> Some(r.Value |> TupleExtensions.ToValueTuple)
                                  | _ -> lexer r.Value)
            |> Seq.tryPick (fun s -> s)
        
        member public this.Lex input = (this :> ILexer<_, _>).Lex input
        interface ILexer<string, struct(char list * State * StackSymbols list * Token list)> with
            member __.Lex input = lexer (input.ToCharArray() |> Array.toList, NewLine, [Z0], [])
